<!DOCTYPE html>
<html>
<head>
	<meta name="generator" content="Hugo 0.75.1" />
  <meta charset="utf-8"/>
  <title>My New Hugo Site</title>

  <meta name="description" content="My New Hugo Site"/>
  <meta name="author" content=""/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <base href="https://Big-Mouth.github.io" />

  <link rel="stylesheet" href="css/fonts.css"/>
  <link rel="stylesheet" href="css/normalize.css"/>
  <link rel="stylesheet" href="css/skeleton.css"/>
  <link rel="stylesheet" href="css/custom.css"/>
  <link rel="stylesheet" href="genericons/genericons.css"/>
  
  
  <link rel="stylesheet" href="highlight/tomorrow-night.css"/>

  <link href="index.xml" rel="alternate" type="application/rss+xml" title="Posts + Links" />
  <link href="links/index.xml" rel="alternate" type="application/rss+xml" title="Links" />
  <link href="posts/index.xml" rel="alternate" type="application/rss+xml" title="Posts" />

  
</head>
<body>

<div id="flex-container">
  <input type="checkbox" id="sidebar-menu-checkbox" />
  <label for="sidebar-menu-checkbox" id="sidebar-menu"></label>

  <div id="fake-sidebar"></div>
  <div id="container">


<div class="posts">

</div>

<hr />

<div class="posts">

<section class="post">
  <header class="post-header">
    <p class="post-infos">
      <time datetime="2021-03-09T22:29:53&#43;08:00">09 Mar 9090, 22:29</time>
    </p>
    <h2><a href="/posts/%E7%89%9B%E7%89%9B%E7%9A%84%E5%B9%82%E8%BF%90%E7%AE%97/">牛牛的幂运算</a></h2>
  </header>
  <div class="post-description">
  链接：https://ac.nowcoder.com/acm/problem/21578 来源：牛客网
 题目描述 牛牛在做一道数学题，他发现自己不怎么会做，请你帮帮他 求有多少a,b,c,d满足a [^b] = c [^ d]， 1&lt;=a,b,c,d&lt;=n, 模 109+7 输入描述: 输入一个整数n (1 ≤ n ≤ 109) 输出描述: 输出一个整数
 示例1
输入 2 输出 6
  示例2 输入 100 输出 21620
  示例3 输入 22306 输出 68467
  备注: 子任务一30分：n&lt;=10000 子任务二30分：n&lt;=1000000 子任务三40分：n&lt;=1000000000
 思路：
这道题对于刚学数论的我来说还是有点难的，所以我就请教了余伟豪，他也想了一上午，于是，在午休的时候，他过掉了这道题，然后跟我讲了他的解题思路。
 首先，我们要清楚题目问我们的是方案的数目，给我们的限制是1&lt;=a,b,c,d&lt;=n，n&lt;=1e9，这个范围较大，于是我们开始摸索：对于a [^b] = c [^ d]，我们先讨论两边的底数，很容易发现，a和c的所有因子必须相等，比如，如果a = 4, c = 6;则a的因子有1， 2；而c的因子有1,2,3，即a和b两数的因子不完全相同，因此，两边无论如何都不可能相等。既然这样，我们不妨假设：a = x[^i], b = x[^j],于是，题目就转化成了求满足条件i * a = j * b的等式的个数，我们先讨论一下i和j的取值范围，由于i,j分别为a和c转化为 **x[^i], x[^j]**之后的指数，而1&lt;a,c &lt;1e9，因此x&gt;=1(当然这个我们等下单独计算)，因此，除掉1之后x&gt;=2，则此时1&lt;i,j&lt;31,然后就是对于我们给定的n，1&lt; x[^i], x[^j]&lt;n，那么中间一定有min{$$ \sqrt[i]{n} $$ ,$$ \sqrt[j]{n} $$}个x，这就对应了x个结果，因为确定了底数之后，对于给定的n，结果一定就只有min{$$ \sqrt[i]{n} $$ ,$$ \sqrt[j]{n} $$}个，比如，假设i = 2, j = 3，n = 100，那么x &lt;= 4（自己想一下为什么），想到这里这一切就结束了吗？然而并没有，不要忘记：当gcd(i,j) !
  
  <br /><a class="readmore" href="/posts/%E7%89%9B%E7%89%9B%E7%9A%84%E5%B9%82%E8%BF%90%E7%AE%97/"><span class="genericon genericon-reply"></span> Read more</a>
  
  </div>
</section>

<section class="post">
  <header class="post-header">
    <p class="post-infos">
      <time datetime="2021-03-09T14:47:24&#43;08:00">09 Mar 9090, 14:47</time>
    </p>
    <h2><a href="/posts/bag_problem/">Bag_problem</a></h2>
  </header>
  <div class="post-description">
  Bag_problem ​	背包问题有很多种，因此，很有必要给他来一个分类。相信很多同学对背包问题都存在着不少误区，想要吃透它却又不知道重何下口，那么，今天，它来了！这篇文章，百分百干货，相信你看完之后，一定收获满满！
首先登场的是：01背包问题  题意：有n件物品和一个容量为m的背包，第i件物品消耗的容量为vi，价值为wi，求解放入哪些物品可以使得背包中总价值最大。注意：每件物品只能选0次或者1次，因此叫做01背包问题。
 对于这类问题，很显然就是用dp，那么就按照闫氏dp分析法，先画一个图：
于是，代码应该马上就能码出来了：
#include&lt;iostream&gt;using namespace std; const int N = 1010; int n, m; int f[N]; int w[N], v[N]; int main(){ scanf(&#34;%d%d&#34;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++){ scanf(&#34;%d%d&#34;, &amp;v[i], &amp;w[i]); } for(int i = 1; i &lt;= n; i ++){ for(int j = m; j &gt;= v[i]; j--){//这里要特别注意，由于v[i]&gt;0，因此，j-v[i]&lt;j,由于原来的二维等式为：f[i][j]=max(f[i-1][j],f[i-1][j-v[i]]+w[i]),如果我们从大到小开始算的话，那么我们在用f[j]的时候，f[j-1]一定没有算过，即我们得到的一定是f[i-1]的状态。  f[j] = max(f[j], f[j - v[i]] + w[i]); } } printf(&#34;%d&#34;, f[m]); return 0; } 有小伙伴可能问，啊这里好像没有初始化呀，而且为啥是j要倒过来遍历呢？
  
  <br /><a class="readmore" href="/posts/bag_problem/"><span class="genericon genericon-reply"></span> Read more</a>
  
  </div>
</section>

<section class="post">
  <header class="post-header">
    <p class="post-infos">
      <time datetime="2020-10-11T10:08:32&#43;08:00">11 Oct 11110, 10:08</time>
    </p>
    <h2><a href="/posts/qieqiang/">Qieqiang</a></h2>
  </header>
  <div class="post-description">
  题解 贴墙   问题的突破口就在于小瓷砖的面积大小，当墙的面积是2的倍数时，则无法将墙壁都贴满，反之一定能够贴满
 如果先将墙的面积算出来的话就需要用到long long的数据类型来储存给的值 用int应该也是可以的，就这题而言，相乘溢出是不会改变结果的奇偶性的 代码如下  #include &lt;iostream&gt; using namespace std; int main() { long long h, w; cin &gt;&gt; h &gt;&gt; w; if (h * w % 2 == 0) { // 如果是2的倍数  cout &lt;&lt; &#34;Yes&#34; &lt;&lt; endl; } else { //如果不是2的倍数  cout &lt;&lt; &#34;No&#34; &lt;&lt; endl; } return 0; }  还有一种更好的办法，不难发现两个正整数相乘结果是奇数的充分必要条件是两个正整数都是奇数，固只需要判断两个数是否同时为奇数（即只要有一个偶数就输出Yes）便可（这是本题真正想考的思路） 代码如下    #include &lt;iostream&gt; using namespace std; int main() { int h, w; cin &gt;&gt; h &gt;&gt; w; if (h % 2 == 0 || w % 2 == 0) {//如果其中有一个是偶数  cout &lt;&lt; &#34;Yes&#34; &lt;&lt; endl; } else { cout &lt;&lt; &#34;No&#34; &lt;&lt; endl; } return 0; } 雕像  一道简单的模拟题，需要注意的一个坑就是如果是闰年的2月29日制作的雕像的话，纪念日就要等到闰年才能庆祝一次 代码如下  #include &lt;iostream&gt; using namespace std; int main() { int y1, m1, d1, x, y2, m2, d2; cin &gt;&gt; y1 &gt;&gt; m1 &gt;&gt; d1 &gt;&gt; x &gt;&gt; y2 &gt;&gt; m2 &gt;&gt; d2; int ans; if (m1 == 2 &amp;&amp; d1 == 29) {//如果是闰年的2月29号  ans = x; for (int i = y1 + 1; i &lt;= y2; i++) {//从第二年开始算,算到今年  if (i % 400 == 0 || (i % 4 == 0 &amp;&amp; i % 100 !
  
  <br /><a class="readmore" href="/posts/qieqiang/"><span class="genericon genericon-reply"></span> Read more</a>
  
  </div>
</section>

<section class="post">
  <header class="post-header">
    <p class="post-infos">
      <time datetime="2020-10-04T11:52:17&#43;08:00">04 Oct 4040, 11:52</time>
    </p>
    <h2><a href="/posts/jjjj/">Jjjj</a></h2>
  </header>
  <div class="post-description">
  代码宏定义 #include&lt;bits/stdc++.h&gt;#define ios std::ios::sync_with_stdio(false) #define sd(n) scanf(&#34;%d&#34;,&amp;n) #define sdd(n,m) scanf(&#34;%d%d&#34;,&amp;n,&amp;m) #define sddd(n,m,k) scanf(&#34;%d%d%d&#34;,&amp;n,&amp;m,&amp;k) #define pd(n) printf(&#34;%d\n&#34;, (n)) #define pdd(n,m) printf(&#34;%d %d\n&#34;, n, m) #define pld(n) printf(&#34;%lld\n&#34;, n) #define pldd(n,m) printf(&#34;%lld %lld\n&#34;, n, m) #define sld(n) scanf(&#34;%lld&#34;,&amp;n) #define sldd(n,m) scanf(&#34;%lld%lld&#34;,&amp;n,&amp;m) #define slddd(n,m,k) scanf(&#34;%lld%lld%lld&#34;,&amp;n,&amp;m,&amp;k) #define sf(n) scanf(&#34;%lf&#34;,&amp;n) #define sff(n,m) scanf(&#34;%lf%lf&#34;,&amp;n,&amp;m) #define sfff(n,m,k) scanf(&#34;%lf%lf%lf&#34;,&amp;n,&amp;m,&amp;k) #define rep(i,a,n) for (int i=a;i&lt;=n;i++) #define per(i,n,a) for (int i=n;i&gt;=a;i--) #define mm(a,n) memset(a, n, sizeof(a)) #define pb push_back #define all(x) (x).
  
  <br /><a class="readmore" href="/posts/jjjj/"><span class="genericon genericon-reply"></span> Read more</a>
  
  </div>
</section>

<section class="post">
  <header class="post-header">
    <p class="post-infos">
      <time datetime="0001-01-01T00:00:00Z">01 Jan 1010, 00:00</time>
    </p>
    <h2><a href="/posts/bfu/"></a></h2>
  </header>
  <div class="post-description">
  经典并查集 在算法笔记上有一道这样的题目
题目描述 有一个叫作“数码世界”的奇异空间，在数码世界里生活着许许多多的数码宝贝，其中有些数码宝贝之间可能是好朋友。并且数码世界有两条不成文的规定： 第一，数码宝贝A和数码宝贝B是好朋友等价于数码宝贝B和数码宝贝A是好朋友。 第二，如果数码宝贝A和数码宝贝C是好朋友，而数码宝贝B和数码宝贝C也是好朋友，那么A和B也是好朋友。
现在给出这些数码宝贝中所有好朋友的信息，问：可以把这些数码宝贝分成多少组，满足每组中的任意两只数码宝贝都是好朋友，且任意两组之间的数码宝贝都不是好朋友。
题目分析 首先，可以看到这是一个分组类型的题目，把相互之间有关系的元素放在一起（并），查询小组数（查）以及合并后的集合（集）
因此，这就是一个并查集的模型。可以把题目中给出的好友的关系视为两结点之间的边，那么在输入这些好友关系时，就可以同时把他们合并（这就要求我们写一个合并函数）这样处理完毕之后就得到了一些集合，而集合的个数呢，就是我们所要求的组数。
那集合的个数要怎么求呢？我们通过观察可以很容易发现：对于同一个集合来说，只存在唯一的根节点，且将其作为所属集合的标识
所以呢，我们只要用一个bool数组来存储根结点即可，当然要考虑一些细节，比如说，可以在给结点编号的同时，初始化isroot数组为false，那什么时候让它为true呢？
当然是要写一个findfather函数，在此函数中，可以做两件事情：
 寻找根节点 压缩路径  当然，这个直接套模板即可，毫无技术含量。
在找到了根节点之后，我们就遍历每一个结点，判断如果它是根节点的话，那么直接让他的bool值为true;
另外，如果还要求分成的组数（但不要求每个集合的元素）的话，就用一个set存储每个根结点的儿子数（每个集合的元素个数）最后输出即可。代码如下：
#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std; const int N = 110; int father[N]; bool isroot[N]; int findfather(int x) {//查找每个节点所在集合的根节点 	int a = x;// 	while (x != father[x]) { x = father[x]; } //路径压缩 	while (a != father[a]) { int z = a;//因为a要被father[a]覆盖掉，所以这里先把原来结点存下来，用于修改father[a]的值 	a = father[a];//a不断地回溯父亲结点 	father[z] = x;//将原来结点的父亲结点改为根结点 	} return x; } void Union(int a, int b) { if (findfather(a) == findfather(b)) return; a = findfather(a); b = findfather(b); father[a] = b; } void init(int n) { for (int i = 1; i &lt;= n; i++) { father[i] = i; isroot[i] = false; } } /* 7 5 1 2 2 3 3 1 1 4 5 6 */ int main() { int n, m, a, b; scanf(&#34;%d%d&#34;, &amp;n, &amp;m); init(n); for (int i = 1; i &lt;= m; i++) { scanf(&#34;%d%d&#34;, &amp;a, &amp;b); Union(a, b); } int ans[N] = { 0 }; for (int i = 1; i &lt;= n; i++) { isroot[findfather(i)] = true; } for (int i = 1; i &lt;= n; i++) { if (father[i] == findfather(i)) ans[findfather(i)]++; } set&lt;int&gt; root; for (int i = 1; i &lt;= n; i++) { if (isroot[i]) { root.
  
  <br /><a class="readmore" href="/posts/bfu/"><span class="genericon genericon-reply"></span> Read more</a>
  
  </div>
</section>

</div>

<footer>
  <p class="footnote">Copyright &copy; 2021: All rights reserved by <a href="mailto:"></a></p>
</footer>

  </div>
  <div id="container-mask"></div>
<div id="sidebar">
<div class="sidebar">
  <div class="sidebar-about">
    <a href="https://Big-Mouth.github.io">
      <img src="media/me.jpg" title="" alt="Me" />
      <h4 class="sidebar-title">My New Hugo Site</h4>
    </a>
    <span class="sidebar-tagline"></span>
  </div>
  <nav class="sidebar-nav">
    <ul class="sidebar-nav-list">
      <li class="sidebar-nav-item nav-home">
        <span class="genericon genericon-home"></span><a class="sidebar-link" href="https://Big-Mouth.github.io">Home</a>
      </li>
      <li class="sidebar-nav-item">
        <a class="genericon genericon-feed" href="posts/index.xml"></a><a class="sidebar-link" href="posts/">Posts/</a>
      </li>
      <li class="sidebar-nav-item">
        <a class="genericon genericon-feed" href="links/index.xml"></a><a class="sidebar-link" href="links/">Links/</a>
      </li>
    </ul>
  </nav>
  <div class="sidebar-externals">
  
  | <a class="genericon genericon-mail" href="mailto:"></a>
  </div>
  <div class="sidebar-bottom">
    <hr />
    <p>Powered by <a href="http://gohugo.io">Hugo</a>.</p> <p>Theme: <a href="https://github.com/TiTi/hurock">Hurock</a>.</p>
    <p>Copyright &copy; 2021.</p> <p>All rights reserved.</p>
  </div>
</div>
</div>

</div>

<script src="highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>





</body>
</html>

